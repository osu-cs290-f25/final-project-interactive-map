---
import Layout from "../layouts/Layout.astro";
import WarningBanner from "../components/WarningBanner.astro";
import ModeSwitcher from "../components/ModeSwitcher.astro";
import DrawingToolbar from "../components/DrawingToolbar.astro";
import MarkerModal from "../components/MarkerModal.astro";
---

<Layout title="The Lands Between | Elden Ring Explorer">
  <WarningBanner />

  <main>
    <!-- Header -->
    <header class="hero">
      <h1 class="hero-title">ELDEN RING</h1>
      <div class="hero-divider"></div>
      <p class="hero-subtitle">The Lands Between</p>
    </header>

    <!-- Map Container -->
    <section class="map-section">
      <div id="map"></div>
      <ModeSwitcher />
      <DrawingToolbar />
    </section>
  </main>

  <MarkerModal />
</Layout>

<style>
  main {
    min-height: 100vh;
    display: flex;
    flex-direction: column;
  }

  .hero {
    padding: 3rem 2rem 2rem;
    text-align: center;
    background: linear-gradient(
      180deg,
      var(--black) 0%,
      var(--black-light) 100%
    );
    border-bottom: 2px solid var(--bronze);
    position: relative;
  }

  .hero::after {
    content: "";
    position: absolute;
    bottom: -1px;
    left: 50%;
    transform: translateX(-50%);
    width: 60%;
    height: 1px;
    background: linear-gradient(90deg, transparent, var(--gold), transparent);
  }

  .hero-title {
    font-size: clamp(2.5rem, 8vw, 5rem);
    color: var(--gold);
    text-shadow:
      0 0 20px rgba(193, 157, 83, 0.3),
      0 4px 8px rgba(0, 0, 0, 0.8);
    margin-bottom: 1rem;
    letter-spacing: 0.15em;
  }

  .hero-divider {
    width: 200px;
    height: 2px;
    background: var(--gold);
    margin: 1rem auto;
    position: relative;
  }

  .hero-divider::before,
  .hero-divider::after {
    content: "";
    position: absolute;
    width: 8px;
    height: 8px;
    background: var(--gold);
    border-radius: 50%;
    top: 50%;
    transform: translateY(-50%);
  }

  .hero-divider::before {
    left: -12px;
  }
  .hero-divider::after {
    right: -12px;
  }

  .hero-subtitle {
    font-size: clamp(0.9rem, 2vw, 1.2rem);
    color: var(--bronze);
    letter-spacing: 0.1em;
    text-transform: uppercase;
    font-weight: 500;
  }

  .map-section {
    flex: 1;
    position: relative;
    min-height: 70vh;
  }

  #map {
    width: 100%;
    height: 100%;
    min-height: 70vh;
    background: var(--black-light);
    border-top: 1px solid var(--brown);
  }

  /* Leaflet overrides */
  :global(.leaflet-container) {
    background: var(--black-light);
    font-family: var(--font-body);
    cursor: crosshair; /* Default cursor for marker mode */
  }

  :global(.leaflet-container.draw-mode) {
    cursor:
      url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24"><text y="20" font-size="20">‚úèÔ∏è</text></svg>')
        0 24,
      auto;
  }

  :global(.leaflet-popup-content-wrapper) {
    background: var(--black-light);
    color: var(--gold);
    border: 1px solid var(--bronze);
    border-radius: 4px;
  }

  :global(.leaflet-popup-tip) {
    background: var(--black-light);
    border: 1px solid var(--bronze);
  }

  :global(.marker-icon) {
    background: none !important;
    border: none !important;
  }

  :global(.marker-pin) {
    font-size: 32px;
    text-shadow:
      0 0 10px rgba(193, 157, 83, 0.8),
      0 2px 4px rgba(0, 0, 0, 0.8);
  }

  /* Marker type colors */
  :global(.marker-Quest) {
    filter: hue-rotate(0deg);
  } /* Gold */
  :global(.marker-Boss) {
    filter: hue-rotate(330deg) brightness(1.2);
  } /* Red */
  :global(.marker-Item) {
    filter: hue-rotate(210deg);
  } /* Blue */
  :global(.marker-NPC) {
    filter: hue-rotate(90deg);
  } /* Green */
  :global(.marker-SiteOfGrace) {
    filter: brightness(1.5);
  } /* White */
  :global(.marker-Other) {
    filter: sepia(1);
  } /* Bronze */

  @media (max-width: 768px) {
    .hero {
      padding: 2rem 1rem 1.5rem;
    }

    .hero-title {
      font-size: 2rem;
    }

    #map {
      min-height: 60vh;
    }
  }
</style>

<script>
  import L from "leaflet";

  // ===== SECURITY: HTML ESCAPING =====
  function escapeHtml(unsafe: string): string {
    if (!unsafe) return "";
    return unsafe
      .replace(/&/g, "&amp;")
      .replace(/</g, "&lt;")
      .replace(/>/g, "&gt;")
      .replace(/"/g, "&quot;")
      .replace(/'/g, "&#039;");
  }

  // ===== STATE =====
  let map: L.Map;
  let currentMode: "marker" | "draw" = "marker";
  let currentTool = "pencil";
  let currentColor = "#c19d53";
  let currentWidth = 3;
  let markers: any[] = [];
  let drawings: any[] = [];
  let allDrawingLayers: L.Polyline[] = [];

  // Drawing state
  let isDrawing = false;
  let currentPath: L.Polyline | null = null;
  let currentPoints: L.LatLng[] = [];

  // Check if logged in
  function isLoggedIn() {
    return document.cookie.includes("session=");
  }

  // Show warning if not logged in
  function showWarning() {
    if (!isLoggedIn()) {
      const banner = document.getElementById("warning-banner");
      if (banner) banner.style.display = "flex";
    }
  }

  // ===== INITIALIZE MAP =====
  function initMap() {
    const imageBounds: L.LatLngBoundsExpression = [
      [0, 0],
      [1000, 1000],
    ];

    map = L.map("map", {
      crs: L.CRS.Simple,
      minZoom: -2,
      maxZoom: 2,
      zoomSnap: 0.25,
      zoomDelta: 0.5,
    });

    const imageUrl = "/EldenRingMap.jpg";
    L.imageOverlay(imageUrl, imageBounds).addTo(map);
    map.fitBounds(imageBounds);

    loadMarkers();
    loadDrawings();
    showWarning();
  }

  // ===== MARKER FUNCTIONS =====
  function loadMarkers() {
    const saved = localStorage.getItem("elden_markers");
    markers = saved ? JSON.parse(saved) : [];
    markers.forEach(renderMarker);
  }

  function saveMarkers() {
    localStorage.setItem("elden_markers", JSON.stringify(markers));
  }

  //

  function getMarkerEmoji(type: string): string {
    const emojis: Record<string, string> = {
      Quest: "üìú",
      Boss: "‚öîÔ∏è",
      Item: "üíé",
      NPC: "üë§",
      Other: "üìç",
    };
    return emojis[type] || "üìç";
  }

  (window as any).deleteMarker = (id: number) => {
    markers = markers.filter((m) => m.id !== id);
    saveMarkers();
    location.reload();
  };

  // ===== DRAWING FUNCTIONS =====
  function loadDrawings() {
    const saved = localStorage.getItem("elden_drawings");
    drawings = saved ? JSON.parse(saved) : [];
    drawings.forEach(renderDrawing);
  }

  function saveDrawings() {
    localStorage.setItem("elden_drawings", JSON.stringify(drawings));
  }

  function renderDrawing(data: any) {
    const coords = JSON.parse(data.coordinates);
    const style = JSON.parse(data.style);

    const line = L.polyline(coords, style).addTo(map);
    allDrawingLayers.push(line);
  }

  function startDrawing(e: L.LeafletMouseEvent) {
    if (currentMode !== "draw" || currentTool === "eraser") return;

    isDrawing = true;
    currentPoints = [e.latlng];

    currentPath = L.polyline([e.latlng], {
      color: currentColor,
      weight: currentWidth,
      opacity: 0.8,
      smoothFactor: 1,
    }).addTo(map);
  }

  function continueDrawing(e: L.LeafletMouseEvent) {
    if (!isDrawing || currentMode !== "draw" || !currentPath) return;

    currentPoints.push(e.latlng);
    currentPath.setLatLngs(currentPoints);
  }

  function finishDrawing(e: L.LeafletMouseEvent) {
    if (!isDrawing || currentMode !== "draw") return;

    isDrawing = false;

    if (currentPoints.length < 2) {
      if (currentPath) map.removeLayer(currentPath);
      currentPath = null;
      currentPoints = [];
      return;
    }

    if (currentPath) {
      allDrawingLayers.push(currentPath);

      const drawing = {
        id: Date.now(),
        coordinates: JSON.stringify(currentPoints.map((p) => [p.lat, p.lng])),
        style: JSON.stringify({
          color: currentColor,
          weight: currentWidth,
          opacity: 0.8,
        }),
      };

      drawings.push(drawing);
      saveDrawings();
      showWarning();
    }

    currentPath = null;
    currentPoints = [];
  }

  function handleEraser(e: L.LeafletMouseEvent) {
    if (currentMode !== "draw" || currentTool !== "eraser") return;

    const clickPoint = e.latlng;
    let closestDrawing: L.Polyline | null = null;
    let minDistance = Infinity;

    allDrawingLayers.forEach((drawing) => {
      const latlngs = drawing.getLatLngs() as L.LatLng[];
      latlngs.forEach((point) => {
        const distance = clickPoint.distanceTo(point);
        if (distance < minDistance && distance < 50) {
          minDistance = distance;
          closestDrawing = drawing;
        }
      });
    });

    if (closestDrawing) {
      map.removeLayer(closestDrawing);
      allDrawingLayers = allDrawingLayers.filter((d) => d !== closestDrawing);
      location.reload(); // Simple refresh to sync with localStorage
    }
  }

  // ===== MODE SWITCHING =====
  function switchMode(mode: "marker" | "draw") {
    currentMode = mode;

    const markerBtn = document.getElementById("marker-mode-btn");
    const drawBtn = document.getElementById("draw-mode-btn");
    const toolbar = document.getElementById("drawing-toolbar");
    const mapContainer = document.getElementById("map");

    if (mode === "marker") {
      markerBtn?.classList.add("active");
      drawBtn?.classList.remove("active");
      if (toolbar) toolbar.style.display = "none";
      mapContainer?.classList.remove("draw-mode");
    } else {
      markerBtn?.classList.remove("active");
      drawBtn?.classList.add("active");
      if (toolbar) toolbar.style.display = "flex";
      mapContainer?.classList.add("draw-mode");
    }
  }

  // ===== MODAL FUNCTIONS =====
  let pendingMarkerCoords: L.LatLng | null = null;

  function openMarkerModal(coords: L.LatLng) {
    pendingMarkerCoords = coords;
    const modal = document.getElementById("marker-modal");
    if (modal) modal.style.display = "flex";

    (document.getElementById("marker-lat") as HTMLInputElement).value =
      coords.lat.toString();
    (document.getElementById("marker-lng") as HTMLInputElement).value =
      coords.lng.toString();
  }

  (window as any).closeMarkerModal = () => {
    const modal = document.getElementById("marker-modal");
    if (modal) modal.style.display = "none";

    (document.getElementById("marker-form") as HTMLFormElement).reset();
    pendingMarkerCoords = null;
  };

  // ===== EVENT LISTENERS =====
  document.addEventListener("DOMContentLoaded", () => {
    initMap();

    // Map click handler
    map.on("click", (e) => {
      if (currentMode === "marker") {
        openMarkerModal(e.latlng);
      } else if (currentMode === "draw" && currentTool === "eraser") {
        handleEraser(e);
      }
    });

    // Drawing handlers
    map.on("mousedown", startDrawing);
    map.on("mousemove", continueDrawing);
    map.on("mouseup", finishDrawing);

    // Mode switcher
    document
      .getElementById("marker-mode-btn")
      ?.addEventListener("click", () => {
        switchMode("marker");
      });

    document.getElementById("draw-mode-btn")?.addEventListener("click", () => {
      switchMode("draw");
    });

    // Drawing tools
    document.querySelectorAll(".tool-btn").forEach((btn) => {
      btn.addEventListener("click", (e) => {
        document
          .querySelectorAll(".tool-btn")
          .forEach((b) => b.classList.remove("active"));
        (e.currentTarget as HTMLElement).classList.add("active");
        currentTool = (e.currentTarget as HTMLElement).dataset.tool || "pencil";
      });
    });

    // Color buttons
    document.querySelectorAll(".color-btn").forEach((btn) => {
      btn.addEventListener("click", (e) => {
        document
          .querySelectorAll(".color-btn")
          .forEach((b) => b.classList.remove("active"));
        (e.currentTarget as HTMLElement).classList.add("active");
        currentColor =
          (e.currentTarget as HTMLElement).dataset.color || "#c19d53";
      });
    });

    // Line width slider
    const slider = document.getElementById("line-width") as HTMLInputElement;
    const sizeValue = document.getElementById("size-value");
    slider?.addEventListener("input", (e) => {
      currentWidth = parseInt((e.target as HTMLInputElement).value);
      if (sizeValue) sizeValue.textContent = `${currentWidth}px`;
    });

    // Reset all
    document.getElementById("reset-all-btn")?.addEventListener("click", () => {
      if (confirm("Delete ALL markers and drawings? This cannot be undone.")) {
        localStorage.removeItem("elden_markers");
        localStorage.removeItem("elden_drawings");
        location.reload();
      }
    });

    // Marker form submission
    document.getElementById("marker-form")?.addEventListener("submit", (e) => {
      e.preventDefault();

      if (!pendingMarkerCoords) return;

      const formData = {
        id: Date.now(),
        lat: pendingMarkerCoords.lat,
        lng: pendingMarkerCoords.lng,
        title: (document.getElementById("marker-title") as HTMLInputElement)
          .value,
        type: (document.getElementById("marker-type") as HTMLSelectElement)
          .value,
        notes: (document.getElementById("marker-notes") as HTMLTextAreaElement)
          .value,
        completed: (
          document.getElementById("marker-completed") as HTMLInputElement
        ).checked,
      };

      markers.push(formData);
      saveMarkers();
      renderMarker(formData);
      (window as any).closeMarkerModal();
      showWarning();
    });
  });

  

  (window as any).showAuthModal = () => {
    alert("OAuth login coming soon! For now, your data is saved locally.");
  };
</script>
